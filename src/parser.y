%code requires{
  #include "ast.hpp"
  #include <cassert>

  extern const Node *g_root; // A way of getting the AST out

  //! This is to fix problems when generating C++
  // We are declaring the functions provided by Flex, so
  // that Bison generated code can call them.
  int yylex(void);
  void yyerror(const char *);
}

// Represents the value associated with any kind of AST node.
%union{
  const Expression *expr;
  double number;
  std::string *string;
}

%type <node> PRIMARY_EXPRESSION POSTFIX_EXPRESSION ARGUMENT_EXPRESSION_LIST UNARY_EXPRESSION
UNARY_OPERATOR CAST_EXPRESSION MULTIPLICATIVE_EXPRESSION ADDITIVE_EXPRESSION SHIFT_EXPRESSION
RELATIONAL_EXPRESSION EQUALITY_EXPRESSION AND_EXPRESSION EXCLUSIVE_OR_EXPRESSION INCLUSIVE_OR_EXPRESSION
LOGICAL_AND_EXPRESSION LOGICAL_OR_EXPRESSION CONDITIONAL_EXPRESSION ASSIGNMENT_EXPRESSION ASSIGNMENT_OPERATOR
EXPRESSION CONSTANT_EXPRESSION DECLARATION DECLARATION_SPECIFIERS INIT_DECLARATOR_LIST INIT_DECLARATOR
STORAGE_CLASS_SPECIFIER TYPE_SPECIFIER STRUCT_OR_UNION_SPECIFIER STRUCT_OR_UNION
STRUCT_DECLARATION_LIST STRUCT_DECLARATION SPECIFIER_QUALIFIER_LIST STRUCT_DECLARATOR_LIST
STRUCT_DECLARATOR ENUM_SPECIFIER ENUMERATOR_LIST ENUMERATOR TYPE_QUALIFIER DECLARATOR DIRECT_DECLARATOR
POINTER TYPE_QUALIFIER_LIST PARAMETER_TYPE_LIST PARAMETER_LIST PARAMETER_DECLARATION IDENTIFIER_LIST
TYPE_NAME ABSTRACT_DECLARATOR DIRECT_ABSTRACT_DECLARATOR INITIALIZER INITIALIZER_LIST
STATEMENT LABELED_STATEMENT COMPOUND_STATEMENT DECLARATION_LIST STATEMENT_LIST EXPRESSION_STATEMENT
SELECTION_STATEMENT ITERATION_STATEMENT JUMP_STATEMENT TRANSLATION_UNIT EXTERNAL_DECLARATION
FUNCTION_DEFINITION

//general
%token T_AUTO T_BREAK T_CASE T_CHAR T_CONST T_CONTINUE T_DEFAULT T_DO T_DOUBLE
%token T_ELSE T_ENUM T_EXTERN T_FLOAT T_FOR T_GOTO T_IF T_INT T_LONG T_REGISTER
%token T_RETURN T_SHORT T_SIGNED T_SIZEOF T_STATIC T_STRUCT T_SWITCH T_TYPEDEF
%token T_UNION T_UNSIGNED T_VOID T_WHILE

//arithmetic and boolean operators
%token T_AND T_NOT T_INVERT T_MINUS T_PLUS T_MULT T_DIV T_MOD
%token T_LT T_GT T_XOR T_OR T_QUESTION T_DOT T_ELLIPSIS

//assignment operators
%token T_RSHIFT_ASSIGN T_LSHIFT_ASSIGN T_ADD_ASSIGN T_SUB_ASSIGN T_MUL_ASSIGN
%token T_DIV_ASSIGN T_MOD_ASSIGN T_AND_ASSIGN T_XOR_ASSIGN T_OR_ASSIGN T_EQ_ASSIGN

//logical operators
%token T_RSHIFT_OP T_LSHIFT_OP T_INC_OP T_DEC_OP T_PTR_OP T_AND_OP T_OR_OP
%token T_LE_OP T_GE_OP T_EQ_OP T_NE_OP

//miscelleneous
%token T_SEMICOLON T_COMMA T_COLON T_L_BRACE T_R_BRACE
%token T_L_PARATHENSIS T_R_PARATHENSIS T_L_BRACKET T_R_BRACKET

//identifiers and constant expressions
%token T_IDENTIFIER T_INT_CONST T_FLOAT_CONST T_CHAR_CONST T_STRING_CONST


%start translation_unit
%%

ROOT
  : SCOPE       { g_root = new RootNode($1); }
  | ROOT SCOPE  { g_root = new RootNode($2); }
  ;



PROGRAM
  : FUNCTION_DEFINITION { $$ = $1; }
  | DECLARATION         { $$ = $1; }
;



PRIMARY_EXPRESSION
	: T_IDENTIFIER
	| T_INT_CONST     { $$ = new IntegerConstant($1); }
	| T_FLOAT_CONST
  | T_CHAR_CONST
  | T_STRING_CONST
	| T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS
	;

POSTFIX_EXPRESSION
	: PRIMARY_EXPRESSION     { $$ = $1; }
	| POSTFIX_EXPRESSION T_L_BRACKET EXPRESSION T_R_BRACKET
	| POSTFIX_EXPRESSION T_L_PARATHENSIS T_R_PARATHENSIS
	| POSTFIX_EXPRESSION T_L_PARATHENSIS ARGUMENT_EXPRESSION_LIST T_R_PARATHENSIS
	| POSTFIX_EXPRESSION T_DOT IDENTIFIER
	| POSTFIX_EXPRESSION T_PTR_OP IDENTIFIER
	| POSTFIX_EXPRESSION T_INC_OP              { $$ = new PostfixExpression($1, "++"); }
	| POSTFIX_EXPRESSION T_DEC_OP              { $$ = new PostfixExpression($1, "--"); }
	;

ARGUMENT_EXPRESSION_LIST
	: ASSIGNMENT_EXPRESSION
	| ARGUMENT_EXPRESSION_LIST T_COMMA ASSIGNMENT_EXPRESSION
	;

UNARY_EXPRESSION
	: POSTFIX_EXPRESSION               { $$ = $1; }
	| T_INC_OP UNARY_EXPRESSION        { $$ = new UnaryExpression("++", $2); }
	| T_DEC_OP UNARY_EXPRESSION        { $$ = new UnaryExpression("--", $2); }
	| UNARY_OPERATOR CAST_EXPRESSION   { $$ = new UnaryExpression(*$1, $2); delete $1; }
	| T_SIZEOF UNARY_EXPRESSION        { $$ = new UnaryExprression( "sizeof", $2 ); }
	| T_SIZEOF T_L_PARATHENSIS TYPE_NAME T_R_PARATHENSIS { $$ = new UnaryExprression( "sizeof", $3 ); }
	;

UNARY_OPERATOR
	: T_AND    { $$ = new std::string("&_"); }
	| T_MULT   { $$ = new std::string("*_"); }
	| T_PLUS   { $$ = new std::string("+_"); }
	| T_MINUS  { $$ = new std::string("-_"); }
	| T_INVERT { $$ = new std::string("~_"); }
	| T_NOT    { $$ = new std::string("!"); }
	;

CAST_EXPRESSION
	: UNARY_EXPRESSION                                           { $$ = $1; }
	| T_L_PARATHENSIS TYPE_NAME T_R_PARATHENSIS CAST_EXPRESSION
	;

MULTIPLICATIVE_EXPRESSION
	: CAST_EXPRESSION                                            { $$ = $1; }
	| MULTIPLICATIVE_EXPRESSION T_MULT CAST_EXPRESSION           { $$ = new MultiplicativeExpression($1, "*", $3); }
	| MULTIPLICATIVE_EXPRESSION T_DIV CAST_EXPRESSION            { $$ = new MultiplicativeExpression($1, "/", $3); }
	| MULTIPLICATIVE_EXPRESSION T_MOD CAST_EXPRESSION            { $$ = new MultiplicativeExpression($1, "%", $3); }
	;

ADDITIVE_EXPRESSION
	: MULTIPLICATIVE_EXPRESSION                                  { $$ = $1; }
	| ADDITIVE_EXPRESSION T_PLUS MULTIPLICATIVE_EXPRESSION       { $$ = new AdditiveExpression($1, "+", $3); }
	| ADDITIVE_EXPRESSION T_MINUS MULTIPLICATIVE_EXPRESSION      { $$ = new AdditiveExpression($1, "-", $3); }
	;

SHIFT_EXPRESSION
	: ADDITIVE_EXPRESSION                                        { $$ = $1; }
	| SHIFT_EXPRESSION T_LSHIFT_OP ADDITIVE_EXPRESSION           { $$ = new ShiftExpression($1, "<<", $3); }
	| SHIFT_EXPRESSION T_RSHIFT_OP ADDITIVE_EXPRESSION           { $$ = new ShiftExpression($1, ">>", $3); }
	;

RELATIONAL_EXPRESSION
	: SHIFT_EXPRESSION                                           { $$ = $1; }
	| RELATIONAL_EXPRESSION T_LT SHIFT_EXPRESSION                { $$ = new RelationalExpression($1, "<", $3); }
	| RELATIONAL_EXPRESSION T_GT SHIFT_EXPRESSION                { $$ = new RelationalExpression($1, ">", $3); }
	| RELATIONAL_EXPRESSION T_LE_OP SHIFT_EXPRESSION             { $$ = new RelationalExpression($1, "<=", $3); }
	| RELATIONAL_EXPRESSION T_GE_OP SHIFT_EXPRESSION             { $$ = new RelationalExpression($1, ">=", $3); }
	;

EQUALITY_EXPRESSION
	: RELATIONAL_EXPRESSION                                      { $$ = $1; }
	| EQUALITY_EXPRESSION T_EQ_OP RELATIONAL_EXPRESSION          { $$ = new EqualityExpression($1, "==", $3); }
	| EQUALITY_EXPRESSION T_NE_OP RELATIONAL_EXPRESSION          { $$ = new EqualityExpression($1, "!=", $3); }
	;

AND_EXPRESSION
	: EQUALITY_EXPRESSION                        { $$ = $1; }
	| AND_EXPRESSION T_AND EQUALITY_EXPRESSION   { $$ = new AndExpression($1, $3); }
	;

EXCLUSIVE_OR_EXPRESSION
	: AND_EXPRESSION                               { $$ = $1; }
	| EXCLUSIVE_OR_EXPRESSION T_XOR AND_EXPRESSION { $$ = new ExclusiveOrExpression($1, $3); }
	;

INCLUSIVE_OR_EXPRESSION
	: EXCLUSIVE_OR_EXPRESSION                                { $$ = $1; }
	| INCLUSIVE_OR_EXPRESSION T_OR EXCLUSIVE_OR_EXPRESSION   { $$ = new InclusiveOrExpression($1, $3); }
	;

LOGICAL_AND_EXPRESSION
	: INCLUSIVE_OR_EXPRESSION                                  { $$ = $1; }
	| LOGICAL_AND_EXPRESSION T_AND_OP INCLUSIVE_OR_EXPRESSION  { $$ = new LogicalAndExpression($1, $3); }
	;

LOGICAL_OR_EXPRESSION
	: LOGICAL_AND_EXPRESSION                                 { $$ = $1; }
	| LOGICAL_OR_EXPRESSION T_OR_OP LOGICAL_AND_EXPRESSION   { $$ = new LogicalOrExpression($1, $3); }
	;

CONDITIONAL_EXPRESSION
	: LOGICAL_OR_EXPRESSION                                                        { $$ = $1; }
	| LOGICAL_OR_EXPRESSION T_QUESTION EXPRESSION T_COLON CONDITIONAL_EXPRESSION   { $$ = new ConditionalExpression($1, $3, $5); }
	;

ASSIGNMENT_EXPRESSION
	: CONDITIONAL_EXPRESSION
	| UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION
	;

ASSIGNMENT_OPERATOR
	: T_EQ_ASSIGN    { $$ = new std::string("="); }
	| T_MUL_ASSIGN   { $$ = new std::string("*="); }
	| T_DIV_ASSIGN   { $$ = new std::string("/="); }
	| T_MOD_ASSIGN   { $$ = new std::string("%="); }
	| T_ADD_ASSIGN   { $$ = new std::string("+="); }
	| T_SUB_ASSIGN   { $$ = new std::string("-="); }
	| T_LEFT_ASSIGN  { $$ = new std::string("<<="); }
	| T_RIGHT_ASSIGN { $$ = new std::string(">>="); }
	| T_AND_ASSIGN   { $$ = new std::string("&="); }
	| T_XOR_ASSIGN   { $$ = new std::string("^="); }
	| T_OR_ASSIGN    { $$ = new std::string("|="); }
	;

EXPRESSION
	: ASSIGNMENT_EXPRESSION
	| EXPRESSION T_COMMA ASSIGNMENT_EXPRESSION
	;

CONSTANT_EXPRESSION
	: CONDITIONAL_EXPRESSION
	;

DECLARATION
	: DECLARATION_SPECIFIERS T_SEMICOLON
	| DECLARATION_SPECIFIERS INIT_DECLARATOR_LIST T_SEMICOLON
	;

DECLARATION_SPECIFIERS
	: STORAGE_CLASS_SPECIFIER
	| STORAGE_CLASS_SPECIFIER DECLARATION_SPECIFIERS
	| TYPE_SPECIFIER
	| TYPE_SPECIFIER DECLARATION_SPECIFIERS
	| TYPE_QUALIFIER
	| TYPE_QUALIFIER DECLARATION_SPECIFIERS
	;

INIT_DECLARATOR_LIST
	: INIT_DECLARATOR
	| INIT_DECLARATOR_LIST T_COMMA INIT_DECLARATOR
	;

INIT_DECLARATOR
	: DECLARATOR
	| DECLARATOR T_EQ_ASSIGN INITIALIZER
	;

STORAGE_CLASS_SPECIFIER
	: T_TYPEDEF
	| T_EXTERN
	| T_STATIC
	| T_AUTO
	| T_REGISTER
	;

TYPE_SPECIFIER
  : T_VOID     { $$ = new std::string("void"); }
	| T_CHAR     { $$ = new std::string("char"); }
	| T_SHORT    { $$ = new std::string("short"); }
	| T_INT      { $$ = new std::string("int"); }
	| T_LONG     { $$ = new std::string("long"); }
	| T_FLOAT    { $$ = new std::string("float"); }
	| T_DOUBLE   { $$ = new std::string("double"); }
	| T_SIGNED   { $$ = new std::string("signed int"); }
	| T_UNSIGNED { $$ = new std::string("unsigned int"); }
	| STRUCT_OR_UNION_SPECIFIER
	| ENUM_SPECIFIER
	| TYPE_NAME
	;

STRUCT_OR_UNION_SPECIFIER
	: STRUCT_OR_UNION T_IDENTIFIER T_L_BRACE STRUCT_DECLARATION_LIST T_R_BRACE
	| STRUCT_OR_UNION T_L_BRACE STRUCT_DECLARATION_LIST T_R_BRACE
	| STRUCT_OR_UNION T_IDENTIFIER
	;

STRUCT_OR_UNION
	: STRUCT
	| UNION
	;

STRUCT_DECLARATION_LIST
	: STRUCT_DECLARATION
	| STRUCT_DECLARATION_LIST STRUCT_DECLARATION
	;

STRUCT_DECLARATION
	: SPECIFIER_QUALIFIER_LIST STRUCT_DECLARATOR_LIST T_SEMICOLON
	;

SPECIFIER_QUALIFIER_LIST
	| TYPE_SPECIFIER           { $$ = $1; }
	| T_CONST TYPE_SPECIFIER   { $$ = new std::string("const " + *$2); delete $2; }
	;

STRUCT_DECLARATOR_LIST
	: STRUCT_DECLARATOR
	| STRUCT_DECLARATOR_LIST T_COMMA STRUCT_DECLARATOR
	;

STRUCT_DECLARATOR
	: DECLARATOR
	| T_COLON CONSTANT_EXPRESSION
	| DECLARATOR T_COLON CONSTANT_EXPRESSION
	;

ENUM_SPECIFIER
	: ENUM T_L_BRACE ENUMERATOR_LIST T_R_BRACE
	| ENUM T_IDENTIFIER T_L_BRACE ENUMERATOR_LIST T_R_BRACE
	| ENUM T_IDENTIFIER
	;

ENUMERATOR_LIST
	: ENUMERATOR
	| ENUMERATOR_LIST T_COMMA ENUMERATOR
	;

ENUMERATOR
	: T_IDENTIFIER
	| T_IDENTIFIER T_EQ_ASSIGN CONSTANT_EXPRESSION
	;


DECLARATOR
	: POINTER DIRECT_DECLARATOR  { $$ = new Variable(*$2, "pointer", nullptr); delete $2; }
	| DIRECT_DECLARATOR          { $$ = $1; }
	;

DIRECT_DECLARATOR
	: T_IDENTIFIER                                 { $$ = new Variable( *$1, "normal", nullptr); delete $1; }
	| T_L_PARATHENSIS DECLARATOR T_R_PARATHENSIS   { $$ = new Variable( *$2, "normal", $3 ); delete $1; }
	| DIRECT_DECLARATOR T_L_BRACKET CONSTANT_EXPRESSION T_R_BRACKET
	| DIRECT_DECLARATOR T_L_BRACKET T_R_BRACKET
	| DIRECT_DECLARATOR T_L_PARATHENSIS PARAMETER_TYPE_LIST T_R_PARATHENSIS
	| DIRECT_DECLARATOR T_L_PARATHENSIS IDENTIFIER_LIST T_R_PARATHENSIS
	| DIRECT_DECLARATOR T_L_PARATHENSIS T_R_PARATHENSIS
	;

POINTER
	: T_MULT                     { $$ = $1; }
	| T_MULT TYPE_QUALIFIER_LIST
	| T_MULT POINTER
	| T_MULT TYPE_QUALIFIER_LIST POINTER
	;

TYPE_QUALIFIER_LIST
	: TYPE_QUALIFIER
	| TYPE_QUALIFIER_LIST TYPE_QUALIFIER
	;


PARAMETER_TYPE_LIST
	: PARAMETER_LIST
	| PARAMETER_LIST T_COMMA T_ELLIPSIS
	;

PARAMETER_LIST
	: PARAMETER_DECLARATION
	| PARAMETER_LIST T_COMMA PARAMETER_DECLARATION
	;

PARAMETER_DECLARATION
	: DECLARATION_SPECIFIERS DECLARATOR
	| DECLARATION_SPECIFIERS ABSTRACT_DECLARATOR
	| DECLARATION_SPECIFIERS
	;

IDENTIFIER_LIST
	: T_IDENTIFIER
	| IDENTIFIER_LIST T_COMMA T_IDENTIFIER
	;

TYPE_NAME
	: SPECIFIER_QUALIFIER_LIST
	| SPECIFIER_QUALIFIER_LIST ABSTRACT_DECLARATOR
	;

ABSTRACT_DECLARATOR
	: POINTER
	| DIRECT_ABSTRACT_DECLARATOR
	| POINTER DIRECT_ABSTRACT_DECLARATOR
	;

DIRECT_ABSTRACT_DECLARATOR
	: T_L_PARATHENSIS ABSTRACT_DECLARATOR T_R_PARATHENSIS
	| T_L_BRACKET T_R_BRACKET
	| T_L_BRACKET CONSTANT_EXPRESSION T_R_BRACKET
	| DIRECT_ABSTRACT_DECLARATOR T_L_BRACKET T_R_BRACKET
	| DIRECT_ABSTRACT_DECLARATOR T_L_BRACKET CONSTANT_EXPRESSION T_R_BRACKET
	| T_L_PARATHENSIS T_R_PARATHENSIS
	| T_L_PARATHENSIS PARAMETER_TYPE_LIST T_R_PARATHENSIS
	| DIRECT_ABSTRACT_DECLARATOR T_L_PARATHENSIS T_R_PARATHENSIS
	| DIRECT_ABSTRACT_DECLARATOR T_L_PARATHENSIS PARAMETER_TYPE_LIST T_R_PARATHENSIS
	;

INITIALIZER
	: ASSIGNMENT_EXPRESSION
	| T_L_BRACE INITIALIZER_LIST T_R_BRACE
	| T_L_BRACE INITIALIZER_LIST T_COMMA T_R_BRACE
	;

INITIALIZER_LIST
	: INITIALIZER
	| INITIALIZER_LIST T_COMMA INITIALIZER
	;

STATEMENT
	: LABELED_STATEMENT    { $$ = $1; }
	| COMPOUND_STATEMENT   { $$ = $1; }
	| EXPRESSION_STATEMENT { $$ = $1; }
	| SELECTION_STATEMENT  { $$ = $1; }
	| ITERATION_STATEMENT  { $$ = $1; }
	| JUMP_STATEMENT       { $$ = $1; }
	;

LABELED_STATEMENT
	: T_IDENTIFIER T_COLON STATEMENT
	| T_CASE CONSTANT_EXPRESSION T_COLON STATEMENT
	| T_DEFAULT T_COLON STATEMENT
	;

COMPOUND_STATEMENT
	: T_L_BRACE T_R_BRACE                   { $$ = new CompoundStatement(nullptr); }
	| T_L_BRACE STATEMENT_LIST T_R_BRACE    { $$ = new CompoundStatement($2); }
	// | T_L_BRACE DECLARATION_LIST T_R_BRACE
	// | T_L_BRACE DECLARATION_LIST STATEMENT_LIST T_R_BRACE
	;

// DECLARATION_LIST
// 	: DECLARATION
// 	| DECLARATION_LIST DECLARATION
// 	;

STATEMENT_LIST
	: STATEMENT                { $$ = new StatementListNode($1, nullptr); }
	| STATEMENT STATEMENT_LIST { $$ = new StatementListNode($1, $2); }
	;

EXPRESSION_STATEMENT
	: T_SEMICOLON
	| EXPRESSION T_SEMICOLON
	;

SELECTION_STATEMENT
	: T_IF T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS STATEMENT
	| T_IF T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS STATEMENT ELSE STATEMENT
	| T_SWITCH T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS STATEMENT
	;

ITERATION_STATEMENT
	: T_WHILE T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS STATEMENT
	| T_DO STATEMENT WHILE T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS T_SEMICOLON
	| T_FOR T_L_PARATHENSIS EXPRESSION_STATEMENT EXPRESSION_STATEMENT T_R_PARATHENSIS STATEMENT
	| T_FOR T_L_PARATHENSIS EXPRESSION_STATEMENT EXPRESSION_STATEMENT EXPRESSION T_R_PARATHENSIS STATEMENT
	;

JUMP_STATEMENT
	// : T_GOTO T_IDENTIFIER T_SEMICOLON
	| T_CONTINUE T_SEMICOLON           { $$ = new ContinueStatement(); }
	| T_BREAK T_SEMICOLON              { $$ = new BreakStatement(); }
	| T_RETURN T_SEMICOLON             { $$ = new ReturnStatement(nullptr); }
	| T_RETURN EXPRESSION T_SEMICOLON  { $$ = new ReturnStatement($2); }
	;

FUNCTION_DEFINITION
	: DECLARATION_SPECIFIERS DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT
	| DECLARATION_SPECIFIERS DECLARATOR COMPOUND_STATEMENT
	| DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT
	| DECLARATOR COMPOUND_STATEMENT
	;

%%
#include <stdio.h>

extern char yytext[];
extern int column;

yyerror(s)
char *s;
{
	fflush(stdout);
	printf("\n%*s\n%*s\n", column, "^", column, s);
}

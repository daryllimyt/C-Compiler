%code requires{
  #include "ast.hpp"

  #include <cassert>

  extern const Expression *g_root; // A way of getting the AST out

  //! This is to fix problems when generating C++
  // We are declaring the functions provided by Flex, so
  // that Bison generated code can call them.
  int yylex(void);
  void yyerror(const char *);
}

// Represents the value associated with any kind of AST node.
%union{
  const Expression *expr;
  double number;
  std::string *string;
}

//general
%token T_AUTO T_BREAK T_CASE T_CHAR T_CONST T_CONTINUE T_DEFAULT T_DO T_DOUBLE
%token T_ELSE T_ENUM T_EXTERN T_FLOAT T_FOR T_GOTO T_IF T_INT T_LONG T_REGISTER
%token T_RETURN T_SHORT T_SIGNED T_SIZEOF T_STATIC T_STRUCT T_SWITCH T_TYPEDEF
%token T_UNION T_UNSIGNED T_VOID T_WHILE

//arithmetic and boolean operators
%token T_AND T_NOT T_INVERT T_MINUS T_PLUS T_MULT T_DIV T_MOD
%token T_LT T_GT T_XOR T_OR T_QUESTION T_DOT T_ELLIPSIS

//assignment operators
%token T_RSHIFT_ASSIGN T_LSHIFT_ASSIGN T_ADD_ASSIGN T_SUB_ASSIGN T_MUL_ASSIGN
%token T_DIV_ASSIGN T_MOD_ASSIGN T_AND_ASSIGN T_XOR_ASSIGN T_OR_ASSIGN T_EQ_ASSIGN

//logical operators
%token T_RSHIFT_OP T_LSHIFT_OP T_INC_OP T_DEC_OP T_PTR_OP T_AND_OP T_OR_OP
%token T_LE_OP T_GE_OP T_EQ_OP T_NE_OP

//miscelleneous
%token T_SEMICOLON T_COMMA T_COLON T_L_BRACE T_R_BRACE
%token T_L_PARATHENSIS T_R_PARATHENSIS T_L_BRACKET T_R_BRACKET

//identifiers and constant expressions
%token T_IDENTIFIER T_INT_CONST T_FLOAT_CONST T_CHAR_CONST T_STRING_CONST


%start translation_unit
%%

PRIMARY_EXPRESSION
	: T_IDENTIFIER
	| T_INT_CONST
	| T_FLOAT_CONST
  | T_CHAR_CONST
  | T_STRING_CONST
	| T_L_PARATHENSIS EXPRESSION T_R_PARATHENSIS
	;

POSTFIX_EXPRESSION
	: PRIMARY_EXPRESSION
	| POSTFIX_EXPRESSION '[' EXPRESSION ']'
	| POSTFIX_EXPRESSION '(' ')'
	| POSTFIX_EXPRESSION '(' ARGUMENT_EXPRESSION_LIST ')'
	| POSTFIX_EXPRESSION '.' IDENTIFIER
	| POSTFIX_EXPRESSION PTR_OP IDENTIFIER
	| POSTFIX_EXPRESSION INC_OP
	| POSTFIX_EXPRESSION DEC_OP
	;

ARGUMENT_EXPRESSION_LIST
	: ASSIGNMENT_EXPRESSION
	| ARGUMENT_EXPRESSION_LIST ',' ASSIGNMENT_EXPRESSION
	;

UNARY_EXPRESSION
	: POSTFIX_EXPRESSION
	| INC_OP UNARY_EXPRESSION
	| DEC_OP UNARY_EXPRESSION
	| UNARY_OPERATOR CAST_EXPRESSION
	| SIZEOF UNARY_EXPRESSION
	| SIZEOF '(' TYPE_NAME ')'
	;

UNARY_OPERATOR
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

CAST_EXPRESSION
	: UNARY_EXPRESSION
	| '(' TYPE_NAME ')' CAST_EXPRESSION
	;

MULTIPLICATIVE_EXPRESSION
	: CAST_EXPRESSION
	| MULTIPLICATIVE_EXPRESSION '*' CAST_EXPRESSION
	| MULTIPLICATIVE_EXPRESSION '/' CAST_EXPRESSION
	| MULTIPLICATIVE_EXPRESSION '%' CAST_EXPRESSION
	;

ADDITIVE_EXPRESSION
	: MULTIPLICATIVE_EXPRESSION
	| ADDITIVE_EXPRESSION '+' MULTIPLICATIVE_EXPRESSION
	| ADDITIVE_EXPRESSION '-' MULTIPLICATIVE_EXPRESSION
	;

SHIFT_EXPRESSION
	: ADDITIVE_EXPRESSION
	| SHIFT_EXPRESSION LEFT_OP ADDITIVE_EXPRESSION
	| SHIFT_EXPRESSION RIGHT_OP ADDITIVE_EXPRESSION
	;

RELATIONAL_EXPRESSION
	: SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION '<' SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION '>' SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION LE_OP SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION GE_OP SHIFT_EXPRESSION
	;

EQUALITY_EXPRESSION
	: RELATIONAL_EXPRESSION
	| EQUALITY_EXPRESSION EQ_OP RELATIONAL_EXPRESSION
	| EQUALITY_EXPRESSION NE_OP RELATIONAL_EXPRESSION
	;

AND_EXPRESSION
	: EQUALITY_EXPRESSION
	| AND_EXPRESSION '&' EQUALITY_EXPRESSION
	;

EXCLUSIVE_OR_EXPRESSION
	: AND_EXPRESSION
	| EXCLUSIVE_OR_EXPRESSION '^' AND_EXPRESSION
	;

INCLUSIVE_OR_EXPRESSION
	: EXCLUSIVE_OR_EXPRESSION
	| INCLUSIVE_OR_EXPRESSION '|' EXCLUSIVE_OR_EXPRESSION
	;

LOGICAL_AND_EXPRESSION
	: INCLUSIVE_OR_EXPRESSION
	| LOGICAL_AND_EXPRESSION AND_OP INCLUSIVE_OR_EXPRESSION
	;

LOGICAL_OR_EXPRESSION
	: LOGICAL_AND_EXPRESSION
	| LOGICAL_OR_EXPRESSION OR_OP LOGICAL_AND_EXPRESSION
	;

CONDITIONAL_EXPRESSION
	: LOGICAL_OR_EXPRESSION
	| LOGICAL_OR_EXPRESSION '?' EXPRESSION ':' CONDITIONAL_EXPRESSION
	;

ASSIGNMENT_EXPRESSION
	: CONDITIONAL_EXPRESSION
	| UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION
	;

ASSIGNMENT_OPERATOR
	: '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

EXPRESSION
	: ASSIGNMENT_EXPRESSION
	| EXPRESSION ',' ASSIGNMENT_EXPRESSION
	;

CONSTANT_EXPRESSION
	: CONDITIONAL_EXPRESSION
	;

DECLARATION
	: DECLARATION_SPECIFIERS ';'
	| DECLARATION_SPECIFIERS INIT_DECLARATOR_LIST ';'
	;

DECLARATION_SPECIFIERS
	: STORAGE_CLASS_SPECIFIER
	| STORAGE_CLASS_SPECIFIER DECLARATION_SPECIFIERS
	| TYPE_SPECIFIER
	| TYPE_SPECIFIER DECLARATION_SPECIFIERS
	| TYPE_QUALIFIER
	| TYPE_QUALIFIER DECLARATION_SPECIFIERS
	;

INIT_DECLARATOR_LIST
	: INIT_DECLARATOR
	| INIT_DECLARATOR_LIST ',' INIT_DECLARATOR
	;

INIT_DECLARATOR
	: DECLARATOR
	| DECLARATOR '=' INITIALIZER
	;

STORAGE_CLASS_SPECIFIER
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

TYPE_SPECIFIER
	: VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| STRUCT_OR_UNION_SPECIFIER
	| ENUM_SPECIFIER
	| TYPE_NAME
	;

STRUCT_OR_UNION_SPECIFIER
	: STRUCT_OR_UNION IDENTIFIER '{' STRUCT_DECLARATION_LIST '}'
	| STRUCT_OR_UNION '{' STRUCT_DECLARATION_LIST '}'
	| STRUCT_OR_UNION IDENTIFIER
	;

STRUCT_OR_UNION
	: STRUCT
	| UNION
	;

STRUCT_DECLARATION_LIST
	: STRUCT_DECLARATION
	| STRUCT_DECLARATION_LIST STRUCT_DECLARATION
	;

STRUCT_DECLARATION
	: SPECIFIER_QUALIFIER_LIST STRUCT_DECLARATOR_LIST ';'
	;

SPECIFIER_QUALIFIER_LIST
	: TYPE_SPECIFIER SPECIFIER_QUALIFIER_LIST
	| TYPE_SPECIFIER
	| TYPE_QUALIFIER SPECIFIER_QUALIFIER_LIST
	| TYPE_QUALIFIER
	;

STRUCT_DECLARATOR_LIST
	: STRUCT_DECLARATOR
	| STRUCT_DECLARATOR_LIST ',' STRUCT_DECLARATOR
	;

STRUCT_DECLARATOR
	: DECLARATOR
	| ':' CONSTANT_EXPRESSION
	| DECLARATOR ':' CONSTANT_EXPRESSION
	;

ENUM_SPECIFIER
	: ENUM '{' ENUMERATOR_LIST '}'
	| ENUM IDENTIFIER '{' ENUMERATOR_LIST '}'
	| ENUM IDENTIFIER
	;

ENUMERATOR_LIST
	: ENUMERATOR
	| ENUMERATOR_LIST ',' ENUMERATOR
	;

ENUMERATOR
	: IDENTIFIER
	| IDENTIFIER '=' CONSTANT_EXPRESSION
	;

TYPE_QUALIFIER
	: CONST
	| VOLATILE
	;

DECLARATOR
	: POINTER DIRECT_DECLARATOR
	| DIRECT_DECLARATOR
	;

DIRECT_DECLARATOR
	: IDENTIFIER
	| '(' DECLARATOR ')'
	| DIRECT_DECLARATOR '[' CONSTANT_EXPRESSION ']'
	| DIRECT_DECLARATOR '[' ']'
	| DIRECT_DECLARATOR '(' PARAMETER_TYPE_LIST ')'
	| DIRECT_DECLARATOR '(' IDENTIFIER_LIST ')'
	| DIRECT_DECLARATOR '(' ')'
	;

POINTER
	: '*'
	| '*' TYPE_QUALIFIER_LIST
	| '*' POINTER
	| '*' TYPE_QUALIFIER_LIST POINTER
	;

TYPE_QUALIFIER_LIST
	: TYPE_QUALIFIER
	| TYPE_QUALIFIER_LIST TYPE_QUALIFIER
	;


PARAMETER_TYPE_LIST
	: PARAMETER_LIST
	| PARAMETER_LIST ',' ELLIPSIS
	;

PARAMETER_LIST
	: PARAMETER_DECLARATION
	| PARAMETER_LIST ',' PARAMETER_DECLARATION
	;

PARAMETER_DECLARATION
	: DECLARATION_SPECIFIERS DECLARATOR
	| DECLARATION_SPECIFIERS ABSTRACT_DECLARATOR
	| DECLARATION_SPECIFIERS
	;

IDENTIFIER_LIST
	: IDENTIFIER
	| IDENTIFIER_LIST ',' IDENTIFIER
	;

TYPE_NAME
	: SPECIFIER_QUALIFIER_LIST
	| SPECIFIER_QUALIFIER_LIST ABSTRACT_DECLARATOR
	;

ABSTRACT_DECLARATOR
	: POINTER
	| DIRECT_ABSTRACT_DECLARATOR
	| POINTER DIRECT_ABSTRACT_DECLARATOR
	;

DIRECT_ABSTRACT_DECLARATOR
	: '(' ABSTRACT_DECLARATOR ')'
	| '[' ']'
	| '[' CONSTANT_EXPRESSION ']'
	| DIRECT_ABSTRACT_DECLARATOR '[' ']'
	| DIRECT_ABSTRACT_DECLARATOR '[' CONSTANT_EXPRESSION ']'
	| '(' ')'
	| '(' PARAMETER_TYPE_LIST ')'
	| DIRECT_ABSTRACT_DECLARATOR '(' ')'
	| DIRECT_ABSTRACT_DECLARATOR '(' PARAMETER_TYPE_LIST ')'
	;

INITIALIZER
	: ASSIGNMENT_EXPRESSION
	| '{' INITIALIZER_LIST '}'
	| '{' INITIALIZER_LIST ',' '}'
	;

INITIALIZER_LIST
	: INITIALIZER
	| INITIALIZER_LIST ',' INITIALIZER
	;

STATEMENT
	: LABELED_STATEMENT
	| COMPOUND_STATEMENT
	| EXPRESSION_STATEMENT
	| SELECTION_STATEMENT
	| ITERATION_STATEMENT
	| JUMP_STATEMENT
	;

LABELED_STATEMENT
	: IDENTIFIER ':' STATEMENT
	| CASE CONSTANT_EXPRESSION ':' STATEMENT
	| DEFAULT ':' STATEMENT
	;

COMPOUND_STATEMENT
	: '{' '}'
	| '{' STATEMENT_LIST '}'
	| '{' DECLARATION_LIST '}'
	| '{' DECLARATION_LIST STATEMENT_LIST '}'
	;

DECLARATION_LIST
	: DECLARATION
	| DECLARATION_LIST DECLARATION
	;

STATEMENT_LIST
	: STATEMENT
	| STATEMENT_LIST STATEMENT
	;

EXPRESSION_STATEMENT
	: ';'
	| EXPRESSION ';'
	;

SELECTION_STATEMENT
	: IF '(' EXPRESSION ')' STATEMENT
	| IF '(' EXPRESSION ')' STATEMENT ELSE STATEMENT
	| SWITCH '(' EXPRESSION ')' STATEMENT
	;

ITERATION_STATEMENT
	: WHILE '(' EXPRESSION ')' STATEMENT
	| DO STATEMENT WHILE '(' EXPRESSION ')' ';'
	| FOR '(' EXPRESSION_STATEMENT EXPRESSION_STATEMENT ')' STATEMENT
	| FOR '(' EXPRESSION_STATEMENT EXPRESSION_STATEMENT EXPRESSION ')' STATEMENT
	;

JUMP_STATEMENT
	: GOTO IDENTIFIER ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN EXPRESSION ';'
	;

TRANSLATION_UNIT
	: EXTERNAL_DECLARATION
	| TRANSLATION_UNIT EXTERNAL_DECLARATION
	;

EXTERNAL_DECLARATION
	: FUNCTION_DEFINITION
	| DECLARATION
	;

FUNCTION_DEFINITION
	: DECLARATION_SPECIFIERS DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT
	| DECLARATION_SPECIFIERS DECLARATOR COMPOUND_STATEMENT
	| DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT
	| DECLARATOR COMPOUND_STATEMENT
	;

%%
#include <stdio.h>

extern char yytext[];
extern int column;

yyerror(s)
char *s;
{
	fflush(stdout);
	printf("\n%*s\n%*s\n", column, "^", column, s);
}
